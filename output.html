<html>
    <head>
        <meta Content-Type:text/html; charset="UTF-8">
        <title>SnuInfoVis Term Project - GPS</title>
    </head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script>

        let SVG_AREA_WIDTH = 500;
        let SVG_AREA_HEIGHT = 500;
        let AREA_MARGINS = {TOP:20, RIGHT:20, BOTTOM:30, LEFT:40};
        let AREA_WIDTH = SVG_AREA_WIDTH - AREA_MARGINS.LEFT - AREA_MARGINS.RIGHT;
        let AREA_HEIGHT = SVG_AREA_HEIGHT - AREA_MARGINS.TOP - AREA_MARGINS.BOTTOM;
        let GENRE_CATEGORY = ['k-pop', 'hiphop', 'classic', 'rock', 'r&b', 'jazz', 'country', 'pop']

        let mData; // load json
        let mMinYear = 1970; // fixed
        let mMaxYear = 0;

        let mSelectedYear = 2010;
        let mSelectedGenre = GENRE_CATEGORY[0];
        let mSelectedIndex = "danceability";
        let mSelectedPopularity = 72;

        d3.json("data.json").then(function(data) {
            mData = data;
            init();
        });

        function init() {
            console.log("mData size : " + mData.length);
            d3.select("h1").text("Hello!");

            // update year range from data.
            for (let i = 0 ; i < mData.length ; i++) {
                let year = mData[i].date.substring(0, 4);
                // mMinYear = Math.min(mMinYear, parseInt(year)); // mMinYear needs to be fixed.
                mMaxYear = Math.max(mMaxYear, parseInt(year));
            }

            drawAreaChart();
            drawVasePlot();
            drawLineChart();
            drawTable();
        }

        // -------------------- UTIL apis --------------------
        function translate(x, y) {
            return 'translate(' + x + ', ' + y + ')';
        }

        function getSongById(id) {
            for (let i = 0 ; i < mData.length ; i++) {
                if (id == mData[i].id) {
                    return mData[i];
                }
            }
        }

        function getSongsByYear(year) {
            let ret = [];
            for (let i = 0 ; i < mData.length ; i++) {
                if (mData[i].date.substring(0, 4) == year) {
                    ret.push(mData[i]);
                }
            }
            return ret;
        }

        function getColorByGenre(genre) {
            for (let i = 0 ; i < GENRE_CATEGORY.length ; i++) {
                if (genre == GENRE_CATEGORY[i]) {
                    //return d3.schemeCategory10[i];
                    return d3.schemeSet3[i];
                }
            }
        }

        // -------------------- DRAWING APIs --------------------
        function drawAreaChart() {
            let areaChartSvg = d3.select('#area');

            // axis
            let areaX = d3.scaleLinear().domain([mMinYear, mMaxYear + 1 /* +1 for 2020 data */ ])
                    .range([0, AREA_WIDTH]);
            let areaXAxis = d3.axisBottom(areaX).tickFormat(d3.format("d"));
            areaChartSvg.append("g").attr('transform', translate(AREA_MARGINS.LEFT,
                    AREA_HEIGHT + AREA_MARGINS.TOP)).call(areaXAxis);

            let areaY = d3.scaleLinear().domain([100, 0]).range([0, AREA_HEIGHT]);
            let areaYAxis = d3.axisLeft(areaY);
            areaChartSvg.append("g").attr('transform', translate(AREA_MARGINS.LEFT, AREA_MARGINS.TOP))
                    .call(areaYAxis);

            let xUnit = AREA_WIDTH / (mMaxYear - mMinYear + 1);
            let yUnit = AREA_HEIGHT / 100;
            let yBase = AREA_HEIGHT + AREA_MARGINS.TOP;

            // prepare prev values
            let prevSongs = getSongsByYear(mMinYear - 1);
            let prevData = {};

            // generate keys
            for (let i = 0 ; i < GENRE_CATEGORY.length ; i++) {
                prevData[ GENRE_CATEGORY[ i ] ] = 0;
            }

            // get counts per key(genre)
            for (let i = 0 ; i < prevSongs.length ; i++) {
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    if (prevSongs[i].genre == GENRE_CATEGORY[j]) {
                        prevData[ GENRE_CATEGORY[j] ]++;
                    }
                }
            }

            // normalize and calculate height values
            for (let i in prevData) {
                prevData[i] = ((prevData[i] / prevSongs.length) * 100) * yUnit;
            }

            for (let i = mMinYear ; i <= mMaxYear ; i++) {
                // prepare cur values
                let curSongs = getSongsByYear(i);
                let curData = {};

                // generate keys
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    curData[ GENRE_CATEGORY[j] ] = 0;
                }

                // get counts
                for (let j = 0 ; j < curSongs.length ; j++) {
                    for (let k = 0 ; k < GENRE_CATEGORY.length ; k++) {
                        if (curSongs[j].genre == GENRE_CATEGORY[k]) {
                            curData[ GENRE_CATEGORY[k] ]++;
                        }
                    }
                }

                // normalize and calculate height values
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    let counts = curData[ GENRE_CATEGORY[j] ];
                    curData[ GENRE_CATEGORY[j] ] = ((counts / curSongs.length) * 100) * yUnit;
                }

                let prevX = AREA_MARGINS.LEFT + 1/* for y axis line */ + (xUnit * (i - mMinYear));
                let curX = prevX + xUnit;
                let accPrevY = 0;
                let accCurY = 0;
                const areaTooltip = d3.select('body').append("div").style("position", "absolute")
                        .style("z-index", "10").style("visibility", "hidden");
                // line with fill from prev to cur
                for (let j = 0 ; j < GENRE_CATEGORY.length ; j++) {
                    let curGenre = GENRE_CATEGORY[j];
                    let curColor = getColorByGenre(curGenre);
                    let dStr = 'M ' + prevX + ' ' + (yBase - accPrevY) +
                            ' V ' + (yBase - accPrevY - (prevData[ curGenre ])) +
                            ' L ' + curX + ' ' + (yBase - accCurY - (curData[ curGenre ])) +
                            ' V ' + (yBase - accCurY);
                    areaChartSvg.append('path').attr('class', curGenre).attr('fill', curColor)
                            .attr('id', i).attr('stroke', curColor).attr('d', dStr)
                            .on('mouseenter', function() {
                                d3.select(this).attr('fill', d3.rgb(curColor).darker(2));
                                return areaTooltip.style("visibility", "visible").text(i + ', ' + curGenre);
                            }).on('mousemove', function() {
                                return areaTooltip.style("top", (event.pageY - 10) + "px")
                                        .style("left", ( event.pageX + 10 ) + "px")
                                        .text(i + ', ' + curGenre);
                            }).on('mouseleave', function() {
                                d3.select(this).attr('fill', curColor);
                                return areaTooltip.style("visibility", "hidden");
                            }).on('click', function() {
                                console.log('mouse click(year : ' + i + ', genre : ' + curGenre + ')');
                                mSelectedYear = i;
                                mSelectedGenre = curGenre;
                                drawVasePlot();
                            });
                    accPrevY += prevData[ curGenre ];
                    accCurY += curData[ curGenre ];
                }
                prevSongs = curSongs;
                prevData = curData;
            }
        }

        function drawVasePlot() {
            // TODO 조남우 draws or updates a chart considering mSelectedYear, mSelectedGenre.
            // TODO update mSelectedIndex as user selection.
            // TODO call drawLineChart().
        }

        function drawLineChart() {
            // TODO 석상윤 draws or updates a chart considering mSelectedYear, mSelectedGenre, mSelectedIndex
            // TODO update mSelectedPopularity as user selection.
            // TODO call drawTable().
        }

        function drawTable() {
            // TODO 남재호 draws or updates a song table filtered by mSelectedYear, mSelectedGenre,
            //      mSelectedIndex, mSelectedPopularity
            // TODO show more info for a song when mouse on
            // TODO open selected song's spotify url.
        }

    </script>
    <body>
        <h1>Loading...</h1>
        <svg id="area" width=500 height=500 />
    </body>
</html>
